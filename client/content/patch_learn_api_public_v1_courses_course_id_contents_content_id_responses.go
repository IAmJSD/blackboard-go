// Code generated by go-swagger; DO NOT EDIT.

package content

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"fmt"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"

	"github.com/jakemakesstuff/blackboard-go/models"
)

// PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDReader is a Reader for the PatchLearnAPIPublicV1CoursesCourseIDContentsContentID structure.
type PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 507:
		result := NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDInsufficientStorage()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDOK creates a PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDOK with default headers values
func NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDOK() *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDOK {
	return &PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDOK{}
}

/*PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDOK handles this case with default header values.

OK
*/
type PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDOK struct {
	Payload *models.Content
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDOK) Error() string {
	return fmt.Sprintf("[PATCH /learn/api/public/v1/courses/{courseId}/contents/{contentId}][%d] patchLearnApiPublicV1CoursesCourseIdContentsContentIdOK  %+v", 200, o.Payload)
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDOK) GetPayload() *models.Content {
	return o.Payload
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Content)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBadRequest creates a PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBadRequest with default headers values
func NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBadRequest() *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBadRequest {
	return &PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBadRequest{}
}

/*PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBadRequest handles this case with default header values.

Bad Request
*/
type PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBadRequest struct {
	Payload *models.RestException
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBadRequest) Error() string {
	return fmt.Sprintf("[PATCH /learn/api/public/v1/courses/{courseId}/contents/{contentId}][%d] patchLearnApiPublicV1CoursesCourseIdContentsContentIdBadRequest  %+v", 400, o.Payload)
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBadRequest) GetPayload() *models.RestException {
	return o.Payload
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.RestException)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDForbidden creates a PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDForbidden with default headers values
func NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDForbidden() *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDForbidden {
	return &PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDForbidden{}
}

/*PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDForbidden handles this case with default header values.

Forbidden
*/
type PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDForbidden struct {
	Payload *models.RestException
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDForbidden) Error() string {
	return fmt.Sprintf("[PATCH /learn/api/public/v1/courses/{courseId}/contents/{contentId}][%d] patchLearnApiPublicV1CoursesCourseIdContentsContentIdForbidden  %+v", 403, o.Payload)
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDForbidden) GetPayload() *models.RestException {
	return o.Payload
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.RestException)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDNotFound creates a PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDNotFound with default headers values
func NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDNotFound() *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDNotFound {
	return &PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDNotFound{}
}

/*PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDNotFound handles this case with default header values.

Not Found
*/
type PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDNotFound struct {
	Payload *models.RestException
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDNotFound) Error() string {
	return fmt.Sprintf("[PATCH /learn/api/public/v1/courses/{courseId}/contents/{contentId}][%d] patchLearnApiPublicV1CoursesCourseIdContentsContentIdNotFound  %+v", 404, o.Payload)
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDNotFound) GetPayload() *models.RestException {
	return o.Payload
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.RestException)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDInsufficientStorage creates a PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDInsufficientStorage with default headers values
func NewPatchLearnAPIPublicV1CoursesCourseIDContentsContentIDInsufficientStorage() *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDInsufficientStorage {
	return &PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDInsufficientStorage{}
}

/*PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDInsufficientStorage handles this case with default header values.

Folder quota exceeded
*/
type PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDInsufficientStorage struct {
	Payload *models.RestException
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDInsufficientStorage) Error() string {
	return fmt.Sprintf("[PATCH /learn/api/public/v1/courses/{courseId}/contents/{contentId}][%d] patchLearnApiPublicV1CoursesCourseIdContentsContentIdInsufficientStorage  %+v", 507, o.Payload)
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDInsufficientStorage) GetPayload() *models.RestException {
	return o.Payload
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDInsufficientStorage) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.RestException)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBody patch learn API public v1 courses course ID contents content ID body
swagger:model PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBody
*/
type PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBody struct {

	// availability
	Availability *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailability `json:"availability,omitempty"`

	// The body text associated with this content. This field supports BbML; see <a target='_blank' href='https://docs.blackboard.com/learn/REST/Blackboard%20Markup%20Language%20-%20BbML.html'>here</a> for more information.
	Body string `json:"body,omitempty"`

	// Extended settings specific to this content item's content handler.
	ContentHandler *models.ContentHandler `json:"contentHandler,omitempty"`

	// The short description of this content.
	//
	// This field is not used in Classic courses.  For Ultra courses this is used to show information directly on the course outline.
	Description string `json:"description,omitempty"`

	// Indicates whether the content is going to open in a new window.
	//
	// **Since**: 3800.10.0
	LaunchInNewWindow bool `json:"launchInNewWindow,omitempty"`

	// The ID of the content's parent.  Note that top-level contents do not have parents. The 'parentId' field is a writable field as of the Bb Learn 3200.6.0 release.  Specifying a new value in PATCH requests allows the Content object to be moved from one parent to another.
	ParentID string `json:"parentId,omitempty"`

	// The position of this content within its parent folder. Position values are zero-based (the first element has a position value of zero, not one). Default position is last in the list of child contents under the parent.
	Position int32 `json:"position,omitempty"`

	// Indicates whether Review Status is enabled for this content. Content items with review status enabled can be marked as reviewed by students. This can be used to track performance and in Adaptive Release rules to control the release of other content. Reviewable field is currently being used only in Classic courses.
	//
	// **Since**: 3700.15.0
	Reviewable bool `json:"reviewable,omitempty"`

	// The title or name of this content. Typically shown as the main text to click in the course outline when accessing the content.
	Title string `json:"title,omitempty"`
}

// Validate validates this patch learn API public v1 courses course ID contents content ID body
func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAvailability(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateContentHandler(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBody) validateAvailability(formats strfmt.Registry) error {

	if swag.IsZero(o.Availability) { // not required
		return nil
	}

	if o.Availability != nil {
		if err := o.Availability.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("input" + "." + "availability")
			}
			return err
		}
	}

	return nil
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBody) validateContentHandler(formats strfmt.Registry) error {

	if swag.IsZero(o.ContentHandler) { // not required
		return nil
	}

	if o.ContentHandler != nil {
		if err := o.ContentHandler.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("input" + "." + "contentHandler")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBody) UnmarshalBinary(b []byte) error {
	var res PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailability Availability
//
// Settings controlling availability of the content to students.
swagger:model PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailability
*/
type PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailability struct {

	// adaptive release
	AdaptiveRelease *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAdaptiveRelease `json:"adaptiveRelease,omitempty"`

	// Whether this content is available to users with the 'guest' role. Defaults to true.
	AllowGuests bool `json:"allowGuests,omitempty"`

	// Whether the content is currently available to students.  Instructors can always access the content.  If set to 'PartiallyVisible', the title will be available to students but the body will not.  Defaults to Yes.
	//
	//
	// | Type      | Description
	//  | --------- | --------- |
	// | Yes |  |
	// | No |  |
	// | PartiallyVisible |  |
	//
	// Enum: [Yes No PartiallyVisible]
	Available string `json:"available,omitempty"`
}

// Validate validates this patch learn API public v1 courses course ID contents content ID params body availability
func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailability) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdaptiveRelease(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAvailable(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailability) validateAdaptiveRelease(formats strfmt.Registry) error {

	if swag.IsZero(o.AdaptiveRelease) { // not required
		return nil
	}

	if o.AdaptiveRelease != nil {
		if err := o.AdaptiveRelease.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("input" + "." + "availability" + "." + "adaptiveRelease")
			}
			return err
		}
	}

	return nil
}

var patchLearnApiPublicV1CoursesCourseIdContentsContentIdParamsBodyAvailabilityTypeAvailablePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Yes","No","PartiallyVisible"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		patchLearnApiPublicV1CoursesCourseIdContentsContentIdParamsBodyAvailabilityTypeAvailablePropEnum = append(patchLearnApiPublicV1CoursesCourseIdContentsContentIdParamsBodyAvailabilityTypeAvailablePropEnum, v)
	}
}

const (

	// PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAvailableYes captures enum value "Yes"
	PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAvailableYes string = "Yes"

	// PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAvailableNo captures enum value "No"
	PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAvailableNo string = "No"

	// PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAvailablePartiallyVisible captures enum value "PartiallyVisible"
	PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAvailablePartiallyVisible string = "PartiallyVisible"
)

// prop value enum
func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailability) validateAvailableEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, patchLearnApiPublicV1CoursesCourseIdContentsContentIdParamsBodyAvailabilityTypeAvailablePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailability) validateAvailable(formats strfmt.Registry) error {

	if swag.IsZero(o.Available) { // not required
		return nil
	}

	// value enum
	if err := o.validateAvailableEnum("input"+"."+"availability"+"."+"available", "body", o.Available); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailability) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailability) UnmarshalBinary(b []byte) error {
	var res PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailability
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAdaptiveRelease AdaptiveRelease
//
// Settings controlling adaptive release of the content to students.
swagger:model PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAdaptiveRelease
*/
type PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAdaptiveRelease struct {

	// The date when this content will no longer be available to students.
	// Format: date-time
	End strfmt.DateTime `json:"end,omitempty"`

	// The date when this content will become available to students.
	// Format: date-time
	Start strfmt.DateTime `json:"start,omitempty"`
}

// Validate validates this patch learn API public v1 courses course ID contents content ID params body availability adaptive release
func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAdaptiveRelease) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStart(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAdaptiveRelease) validateEnd(formats strfmt.Registry) error {

	if swag.IsZero(o.End) { // not required
		return nil
	}

	if err := validate.FormatOf("input"+"."+"availability"+"."+"adaptiveRelease"+"."+"end", "body", "date-time", o.End.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAdaptiveRelease) validateStart(formats strfmt.Registry) error {

	if swag.IsZero(o.Start) { // not required
		return nil
	}

	if err := validate.FormatOf("input"+"."+"availability"+"."+"adaptiveRelease"+"."+"start", "body", "date-time", o.Start.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAdaptiveRelease) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAdaptiveRelease) UnmarshalBinary(b []byte) error {
	var res PatchLearnAPIPublicV1CoursesCourseIDContentsContentIDParamsBodyAvailabilityAdaptiveRelease
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
