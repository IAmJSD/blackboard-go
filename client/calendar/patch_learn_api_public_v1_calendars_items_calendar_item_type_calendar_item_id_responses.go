// Code generated by go-swagger; DO NOT EDIT.

package calendar

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"

	"github.com/jakemakesstuff/blackboard-go/models"
)

// PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDReader is a Reader for the PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemID structure.
type PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewPatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewPatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewPatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewPatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDOK creates a PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDOK with default headers values
func NewPatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDOK() *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDOK {
	return &PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDOK{}
}

/*PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDOK handles this case with default header values.

OK
*/
type PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDOK struct {
	Payload *models.CalendarItem
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDOK) Error() string {
	return fmt.Sprintf("[PATCH /learn/api/public/v1/calendars/items/{calendarItemType}/{calendarItemId}][%d] patchLearnApiPublicV1CalendarsItemsCalendarItemTypeCalendarItemIdOK  %+v", 200, o.Payload)
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDOK) GetPayload() *models.CalendarItem {
	return o.Payload
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.CalendarItem)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBadRequest creates a PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBadRequest with default headers values
func NewPatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBadRequest() *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBadRequest {
	return &PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBadRequest{}
}

/*PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBadRequest handles this case with default header values.

Bad Request
*/
type PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBadRequest struct {
	Payload *models.RestException
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBadRequest) Error() string {
	return fmt.Sprintf("[PATCH /learn/api/public/v1/calendars/items/{calendarItemType}/{calendarItemId}][%d] patchLearnApiPublicV1CalendarsItemsCalendarItemTypeCalendarItemIdBadRequest  %+v", 400, o.Payload)
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBadRequest) GetPayload() *models.RestException {
	return o.Payload
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.RestException)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDForbidden creates a PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDForbidden with default headers values
func NewPatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDForbidden() *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDForbidden {
	return &PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDForbidden{}
}

/*PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDForbidden handles this case with default header values.

Forbidden
*/
type PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDForbidden struct {
	Payload *models.RestException
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDForbidden) Error() string {
	return fmt.Sprintf("[PATCH /learn/api/public/v1/calendars/items/{calendarItemType}/{calendarItemId}][%d] patchLearnApiPublicV1CalendarsItemsCalendarItemTypeCalendarItemIdForbidden  %+v", 403, o.Payload)
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDForbidden) GetPayload() *models.RestException {
	return o.Payload
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.RestException)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDNotFound creates a PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDNotFound with default headers values
func NewPatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDNotFound() *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDNotFound {
	return &PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDNotFound{}
}

/*PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDNotFound handles this case with default header values.

Not Found
*/
type PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDNotFound struct {
	Payload *models.RestException
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDNotFound) Error() string {
	return fmt.Sprintf("[PATCH /learn/api/public/v1/calendars/items/{calendarItemType}/{calendarItemId}][%d] patchLearnApiPublicV1CalendarsItemsCalendarItemTypeCalendarItemIdNotFound  %+v", 404, o.Payload)
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDNotFound) GetPayload() *models.RestException {
	return o.Payload
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.RestException)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBody patch learn API public v1 calendars items calendar item type calendar item ID body
swagger:model PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBody
*/
type PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBody struct {

	// Description of the calendar item.
	Description string `json:"description,omitempty"`

	// Whether resizing of the calendar item should NOT be allowed.
	DisableResizing bool `json:"disableResizing,omitempty"`

	// dynamic calendar item props
	DynamicCalendarItemProps *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDParamsBodyDynamicCalendarItemProps `json:"dynamicCalendarItemProps,omitempty"`

	// End date of the calendar item either in the past if the calendar item is for an event that's already end OR in the future if it's for an event to end in the future. This is always set and should occur after the start date.
	// Format: date-time
	End strfmt.DateTime `json:"end,omitempty"`

	// Location of the calendar item and it cannot exceed 1024 characters.
	Location string `json:"location,omitempty"`

	// Recurring definition if the calendar item is a repeatable calendar item. This object must be defined for <code>OfficeHours</code> type calendar items.
	Recurrence *models.CalendarItemRecurrence `json:"recurrence,omitempty"`

	// Start date of the calendar item either in the past if the calendar item is for an event that's already started OR in the future if it's for an event to start in the future. This is always set and should occur before the end date.
	// Format: date-time
	Start strfmt.DateTime `json:"start,omitempty"`

	// Title of the calendar item. Title length cannot exceed 255 characters.
	Title string `json:"title,omitempty"`
}

// Validate validates this patch learn API public v1 calendars items calendar item type calendar item ID body
func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDynamicCalendarItemProps(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRecurrence(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStart(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBody) validateDynamicCalendarItemProps(formats strfmt.Registry) error {

	if swag.IsZero(o.DynamicCalendarItemProps) { // not required
		return nil
	}

	if o.DynamicCalendarItemProps != nil {
		if err := o.DynamicCalendarItemProps.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("input" + "." + "dynamicCalendarItemProps")
			}
			return err
		}
	}

	return nil
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBody) validateEnd(formats strfmt.Registry) error {

	if swag.IsZero(o.End) { // not required
		return nil
	}

	if err := validate.FormatOf("input"+"."+"end", "body", "date-time", o.End.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBody) validateRecurrence(formats strfmt.Registry) error {

	if swag.IsZero(o.Recurrence) { // not required
		return nil
	}

	if o.Recurrence != nil {
		if err := o.Recurrence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("input" + "." + "recurrence")
			}
			return err
		}
	}

	return nil
}

func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBody) validateStart(formats strfmt.Registry) error {

	if swag.IsZero(o.Start) { // not required
		return nil
	}

	if err := validate.FormatOf("input"+"."+"start", "body", "date-time", o.Start.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBody) UnmarshalBinary(b []byte) error {
	var res PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDParamsBodyDynamicCalendarItemProps DynamicCalendarItemProps
//
// Extra calendar item properties if it is a GradebookColumn calendar item.
swagger:model PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDParamsBodyDynamicCalendarItemProps
*/
type PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDParamsBodyDynamicCalendarItemProps struct {

	// The dynamic calendar item can be attempted (can have attempts made against it) and the current user (in context) has permission/entitlement to grade attempts for the object represented by this calendar item.
	Attemptable bool `json:"attemptable,omitempty"`

	// Returns the gradeableItem categoryId value .it is only set if the calendar event is dynamically created based on a single grade book column
	CategoryID string `json:"categoryId,omitempty"`

	// The dynamic calendar item is only visible during a specific windows of time.
	DateRangeLimited bool `json:"dateRangeLimited,omitempty"`

	// Returns a human readable string describing the type of calendar item represented (e.g. assignment, test, etc.).
	EventType string `json:"eventType,omitempty"`

	// The dynamic calendar item can be graded and the current user (in context) has permission/entitlement to grade attempts for the object represented by this calendar item.
	Gradable bool `json:"gradable,omitempty"`
}

// Validate validates this patch learn API public v1 calendars items calendar item type calendar item ID params body dynamic calendar item props
func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDParamsBodyDynamicCalendarItemProps) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDParamsBodyDynamicCalendarItemProps) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDParamsBodyDynamicCalendarItemProps) UnmarshalBinary(b []byte) error {
	var res PatchLearnAPIPublicV1CalendarsItemsCalendarItemTypeCalendarItemIDParamsBodyDynamicCalendarItemProps
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
