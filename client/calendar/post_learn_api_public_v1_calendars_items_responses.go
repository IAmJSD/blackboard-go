// Code generated by go-swagger; DO NOT EDIT.

package calendar

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"fmt"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"

	"github.com/jakemakesstuff/blackboard-go/models"
)

// PostLearnAPIPublicV1CalendarsItemsReader is a Reader for the PostLearnAPIPublicV1CalendarsItems structure.
type PostLearnAPIPublicV1CalendarsItemsReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PostLearnAPIPublicV1CalendarsItemsReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewPostLearnAPIPublicV1CalendarsItemsCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPostLearnAPIPublicV1CalendarsItemsBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewPostLearnAPIPublicV1CalendarsItemsForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewPostLearnAPIPublicV1CalendarsItemsNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewPostLearnAPIPublicV1CalendarsItemsCreated creates a PostLearnAPIPublicV1CalendarsItemsCreated with default headers values
func NewPostLearnAPIPublicV1CalendarsItemsCreated() *PostLearnAPIPublicV1CalendarsItemsCreated {
	return &PostLearnAPIPublicV1CalendarsItemsCreated{}
}

/*PostLearnAPIPublicV1CalendarsItemsCreated handles this case with default header values.

Created
*/
type PostLearnAPIPublicV1CalendarsItemsCreated struct {
	Payload *models.CalendarItem
}

func (o *PostLearnAPIPublicV1CalendarsItemsCreated) Error() string {
	return fmt.Sprintf("[POST /learn/api/public/v1/calendars/items][%d] postLearnApiPublicV1CalendarsItemsCreated  %+v", 201, o.Payload)
}

func (o *PostLearnAPIPublicV1CalendarsItemsCreated) GetPayload() *models.CalendarItem {
	return o.Payload
}

func (o *PostLearnAPIPublicV1CalendarsItemsCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.CalendarItem)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostLearnAPIPublicV1CalendarsItemsBadRequest creates a PostLearnAPIPublicV1CalendarsItemsBadRequest with default headers values
func NewPostLearnAPIPublicV1CalendarsItemsBadRequest() *PostLearnAPIPublicV1CalendarsItemsBadRequest {
	return &PostLearnAPIPublicV1CalendarsItemsBadRequest{}
}

/*PostLearnAPIPublicV1CalendarsItemsBadRequest handles this case with default header values.

Bad Request
*/
type PostLearnAPIPublicV1CalendarsItemsBadRequest struct {
	Payload *models.RestException
}

func (o *PostLearnAPIPublicV1CalendarsItemsBadRequest) Error() string {
	return fmt.Sprintf("[POST /learn/api/public/v1/calendars/items][%d] postLearnApiPublicV1CalendarsItemsBadRequest  %+v", 400, o.Payload)
}

func (o *PostLearnAPIPublicV1CalendarsItemsBadRequest) GetPayload() *models.RestException {
	return o.Payload
}

func (o *PostLearnAPIPublicV1CalendarsItemsBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.RestException)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostLearnAPIPublicV1CalendarsItemsForbidden creates a PostLearnAPIPublicV1CalendarsItemsForbidden with default headers values
func NewPostLearnAPIPublicV1CalendarsItemsForbidden() *PostLearnAPIPublicV1CalendarsItemsForbidden {
	return &PostLearnAPIPublicV1CalendarsItemsForbidden{}
}

/*PostLearnAPIPublicV1CalendarsItemsForbidden handles this case with default header values.

Forbidden
*/
type PostLearnAPIPublicV1CalendarsItemsForbidden struct {
	Payload *models.RestException
}

func (o *PostLearnAPIPublicV1CalendarsItemsForbidden) Error() string {
	return fmt.Sprintf("[POST /learn/api/public/v1/calendars/items][%d] postLearnApiPublicV1CalendarsItemsForbidden  %+v", 403, o.Payload)
}

func (o *PostLearnAPIPublicV1CalendarsItemsForbidden) GetPayload() *models.RestException {
	return o.Payload
}

func (o *PostLearnAPIPublicV1CalendarsItemsForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.RestException)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostLearnAPIPublicV1CalendarsItemsNotFound creates a PostLearnAPIPublicV1CalendarsItemsNotFound with default headers values
func NewPostLearnAPIPublicV1CalendarsItemsNotFound() *PostLearnAPIPublicV1CalendarsItemsNotFound {
	return &PostLearnAPIPublicV1CalendarsItemsNotFound{}
}

/*PostLearnAPIPublicV1CalendarsItemsNotFound handles this case with default header values.

Not Found
*/
type PostLearnAPIPublicV1CalendarsItemsNotFound struct {
	Payload *models.RestException
}

func (o *PostLearnAPIPublicV1CalendarsItemsNotFound) Error() string {
	return fmt.Sprintf("[POST /learn/api/public/v1/calendars/items][%d] postLearnApiPublicV1CalendarsItemsNotFound  %+v", 404, o.Payload)
}

func (o *PostLearnAPIPublicV1CalendarsItemsNotFound) GetPayload() *models.RestException {
	return o.Payload
}

func (o *PostLearnAPIPublicV1CalendarsItemsNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.RestException)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*PostLearnAPIPublicV1CalendarsItemsBody post learn API public v1 calendars items body
swagger:model PostLearnAPIPublicV1CalendarsItemsBody
*/
type PostLearnAPIPublicV1CalendarsItemsBody struct {

	// Calendar source identifier which indicates the calendar on which the calendar item was created. Examples of possible values : "PERSONAL", "INSTITUTION", and course id in the format of "_3_1".
	// Required: true
	CalendarID *string `json:"calendarId"`

	// Description of the calendar item.
	Description string `json:"description,omitempty"`

	// Whether resizing of the calendar item should NOT be allowed.
	DisableResizing bool `json:"disableResizing,omitempty"`

	// dynamic calendar item props
	DynamicCalendarItemProps *PostLearnAPIPublicV1CalendarsItemsParamsBodyDynamicCalendarItemProps `json:"dynamicCalendarItemProps,omitempty"`

	// End date of the calendar item either in the past if the calendar item is for an event that's already end OR in the future if it's for an event to end in the future. This is always set and should occur after the start date.
	// Format: date-time
	End strfmt.DateTime `json:"end,omitempty"`

	// Location of the calendar item and it cannot exceed 1024 characters.
	Location string `json:"location,omitempty"`

	// Recurring definition if the calendar item is a repeatable calendar item. This object must be defined for <code>OfficeHours</code> type calendar items.
	Recurrence *models.CalendarItemRecurrence `json:"recurrence,omitempty"`

	// Start date of the calendar item either in the past if the calendar item is for an event that's already started OR in the future if it's for an event to start in the future. This is always set and should occur before the end date.
	// Format: date-time
	Start strfmt.DateTime `json:"start,omitempty"`

	// Title of the calendar item. Title length cannot exceed 255 characters.
	Title string `json:"title,omitempty"`

	// The type of this Calendar Item.
	//
	//
	// | Type      | Description
	//  | --------- | --------- |
	// | Course |  |
	// | GradebookColumn | Read only. |
	// | Institution |  |
	// | OfficeHours |  |
	// | Personal |  |
	//
	// Required: true
	// Enum: [Course GradebookColumn Institution OfficeHours Personal]
	Type *string `json:"type"`
}

// Validate validates this post learn API public v1 calendars items body
func (o *PostLearnAPIPublicV1CalendarsItemsBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCalendarID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDynamicCalendarItemProps(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRecurrence(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStart(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostLearnAPIPublicV1CalendarsItemsBody) validateCalendarID(formats strfmt.Registry) error {

	if err := validate.Required("input"+"."+"calendarId", "body", o.CalendarID); err != nil {
		return err
	}

	return nil
}

func (o *PostLearnAPIPublicV1CalendarsItemsBody) validateDynamicCalendarItemProps(formats strfmt.Registry) error {

	if swag.IsZero(o.DynamicCalendarItemProps) { // not required
		return nil
	}

	if o.DynamicCalendarItemProps != nil {
		if err := o.DynamicCalendarItemProps.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("input" + "." + "dynamicCalendarItemProps")
			}
			return err
		}
	}

	return nil
}

func (o *PostLearnAPIPublicV1CalendarsItemsBody) validateEnd(formats strfmt.Registry) error {

	if swag.IsZero(o.End) { // not required
		return nil
	}

	if err := validate.FormatOf("input"+"."+"end", "body", "date-time", o.End.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *PostLearnAPIPublicV1CalendarsItemsBody) validateRecurrence(formats strfmt.Registry) error {

	if swag.IsZero(o.Recurrence) { // not required
		return nil
	}

	if o.Recurrence != nil {
		if err := o.Recurrence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("input" + "." + "recurrence")
			}
			return err
		}
	}

	return nil
}

func (o *PostLearnAPIPublicV1CalendarsItemsBody) validateStart(formats strfmt.Registry) error {

	if swag.IsZero(o.Start) { // not required
		return nil
	}

	if err := validate.FormatOf("input"+"."+"start", "body", "date-time", o.Start.String(), formats); err != nil {
		return err
	}

	return nil
}

var postLearnApiPublicV1CalendarsItemsBodyTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Course","GradebookColumn","Institution","OfficeHours","Personal"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		postLearnApiPublicV1CalendarsItemsBodyTypeTypePropEnum = append(postLearnApiPublicV1CalendarsItemsBodyTypeTypePropEnum, v)
	}
}

const (

	// PostLearnAPIPublicV1CalendarsItemsBodyTypeCourse captures enum value "Course"
	PostLearnAPIPublicV1CalendarsItemsBodyTypeCourse string = "Course"

	// PostLearnAPIPublicV1CalendarsItemsBodyTypeGradebookColumn captures enum value "GradebookColumn"
	PostLearnAPIPublicV1CalendarsItemsBodyTypeGradebookColumn string = "GradebookColumn"

	// PostLearnAPIPublicV1CalendarsItemsBodyTypeInstitution captures enum value "Institution"
	PostLearnAPIPublicV1CalendarsItemsBodyTypeInstitution string = "Institution"

	// PostLearnAPIPublicV1CalendarsItemsBodyTypeOfficeHours captures enum value "OfficeHours"
	PostLearnAPIPublicV1CalendarsItemsBodyTypeOfficeHours string = "OfficeHours"

	// PostLearnAPIPublicV1CalendarsItemsBodyTypePersonal captures enum value "Personal"
	PostLearnAPIPublicV1CalendarsItemsBodyTypePersonal string = "Personal"
)

// prop value enum
func (o *PostLearnAPIPublicV1CalendarsItemsBody) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, postLearnApiPublicV1CalendarsItemsBodyTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *PostLearnAPIPublicV1CalendarsItemsBody) validateType(formats strfmt.Registry) error {

	if err := validate.Required("input"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	// value enum
	if err := o.validateTypeEnum("input"+"."+"type", "body", *o.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostLearnAPIPublicV1CalendarsItemsBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostLearnAPIPublicV1CalendarsItemsBody) UnmarshalBinary(b []byte) error {
	var res PostLearnAPIPublicV1CalendarsItemsBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PostLearnAPIPublicV1CalendarsItemsParamsBodyDynamicCalendarItemProps DynamicCalendarItemProps
//
// Extra calendar item properties if it is a GradebookColumn calendar item.
swagger:model PostLearnAPIPublicV1CalendarsItemsParamsBodyDynamicCalendarItemProps
*/
type PostLearnAPIPublicV1CalendarsItemsParamsBodyDynamicCalendarItemProps struct {

	// The dynamic calendar item can be attempted (can have attempts made against it) and the current user (in context) has permission/entitlement to grade attempts for the object represented by this calendar item.
	Attemptable bool `json:"attemptable,omitempty"`

	// Returns the gradeableItem categoryId value .it is only set if the calendar event is dynamically created based on a single grade book column
	CategoryID string `json:"categoryId,omitempty"`

	// The dynamic calendar item is only visible during a specific windows of time.
	DateRangeLimited bool `json:"dateRangeLimited,omitempty"`

	// Returns a human readable string describing the type of calendar item represented (e.g. assignment, test, etc.).
	EventType string `json:"eventType,omitempty"`

	// The dynamic calendar item can be graded and the current user (in context) has permission/entitlement to grade attempts for the object represented by this calendar item.
	Gradable bool `json:"gradable,omitempty"`
}

// Validate validates this post learn API public v1 calendars items params body dynamic calendar item props
func (o *PostLearnAPIPublicV1CalendarsItemsParamsBodyDynamicCalendarItemProps) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostLearnAPIPublicV1CalendarsItemsParamsBodyDynamicCalendarItemProps) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostLearnAPIPublicV1CalendarsItemsParamsBodyDynamicCalendarItemProps) UnmarshalBinary(b []byte) error {
	var res PostLearnAPIPublicV1CalendarsItemsParamsBodyDynamicCalendarItemProps
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
