// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CourseV2 course v2
//
// swagger:model CourseV2
type CourseV2 struct {

	// Whether guests (users with the role guest) are allowed access to the course. Defaults to true.
	AllowGuests bool `json:"allowGuests,omitempty"`

	// availability
	Availability *CourseV2Availability `json:"availability,omitempty"`

	// This status does not affect availability of the course for viewing in any way. closedComplete is valid for both Ultra and Classic courses. If an Ultra course is in closedComplete mode, updates are not possible. For a Classic course in closedComplete mode, updates are still possible (through Web UI but not through REST i.e. closed is enforced for original courses when updated through REST the same way Ultra courses are blocked) but new notifications are not generated.
	ClosedComplete bool `json:"closedComplete,omitempty"`

	// The Course ID attribute, shown to users in the UI.
	// Required: true
	// Read Only: true
	// Max Length: 100
	CourseID string `json:"courseId"`

	// The date this course was created.
	// Required: true
	// Read Only: true
	// Format: date-time
	Created strfmt.DateTime `json:"created"`

	// The ID of the data source associated with this course. This may optionally be the data source's externalId using the syntax "externalId:math101".
	DataSourceID string `json:"dataSourceId,omitempty"`

	// The description of the course.
	Description string `json:"description,omitempty"`

	// enrollment
	Enrollment *CourseV2Enrollment `json:"enrollment,omitempty"`

	// A URL corresponding to the Course Page for the course.  Formatting varies based on whether the course is rendered using Classic or Ultra Course View
	//
	// **Since**: 3200.3.0
	// Required: true
	// Read Only: true
	ExternalAccessURL string `json:"externalAccessUrl"`

	// An optional externally-defined unique ID for the course. Defaults to the courseId.
	//
	// Formerly known as 'batchUid'.
	// Max Length: 256
	ExternalID string `json:"externalId,omitempty"`

	// A URL for viewing the Course Page for the course as a guest.  Formatting varies based on whether the course is rendered using Classic or Ultra Course View
	//
	// **Since**: 3200.3.0
	// Required: true
	// Read Only: true
	GuestAccessURL string `json:"guestAccessUrl"`

	// Whether the course has any cross-listed children.
	//
	// **Since**: 3000.11.0
	// Required: true
	// Read Only: true
	HasChildren bool `json:"hasChildren"`

	// The primary ID of the course.
	// Required: true
	// Read Only: true
	ID string `json:"id"`

	// locale
	Locale *CourseV2Locale `json:"locale,omitempty"`

	// The date this course was last modified.
	//
	// **Since**: 3500.4.0
	// Required: true
	// Read Only: true
	// Format: date-time
	Modified strfmt.DateTime `json:"modified"`

	// The name of the course.
	// Required: true
	// Max Length: 333
	Name *string `json:"name"`

	// Whether this object represents an Organization. Defaults to false.
	// Required: true
	// Read Only: true
	Organization bool `json:"organization"`

	// The cross-listed parentId associated with the course, if the course is a child course.
	//
	// **Since**: 3000.11.0
	// Required: true
	// Read Only: true
	ParentID string `json:"parentId"`

	// The ID of the term associated to this course. This may optionally be the term's externalId using the syntax "externalId:spring.2016".
	TermID string `json:"termId,omitempty"`

	// Whether the course is rendered using Classic or Ultra Course View.
	//
	//
	// | Type      | Description
	//  | --------- | --------- |
	// | Undecided | The ultra status is not decided. |
	// | Classic | The course is decided as classic. |
	// | Ultra | The course is decided as ultra |
	// | UltraPreview | The course is currently in Ultra mode but during the preview state where it may still be reverted via a Restore to the classic state |
	//
	// Required: true
	// Read Only: true
	// Enum: [Undecided Classic Ultra UltraPreview]
	UltraStatus string `json:"ultraStatus"`

	// A secondary unique ID for the course. Used by LTI launches and other inter-server operations.
	// Required: true
	// Read Only: true
	// Max Length: 32
	UUID string `json:"uuid"`
}

// Validate validates this course v2
func (m *CourseV2) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailability(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCourseID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnrollment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalAccessURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGuestAccessURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHasChildren(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocale(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModified(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrganization(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParentID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUltraStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CourseV2) validateAvailability(formats strfmt.Registry) error {

	if swag.IsZero(m.Availability) { // not required
		return nil
	}

	if m.Availability != nil {
		if err := m.Availability.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("availability")
			}
			return err
		}
	}

	return nil
}

func (m *CourseV2) validateCourseID(formats strfmt.Registry) error {

	if err := validate.RequiredString("courseId", "body", string(m.CourseID)); err != nil {
		return err
	}

	if err := validate.MaxLength("courseId", "body", string(m.CourseID), 100); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2) validateCreated(formats strfmt.Registry) error {

	if err := validate.Required("created", "body", strfmt.DateTime(m.Created)); err != nil {
		return err
	}

	if err := validate.FormatOf("created", "body", "date-time", m.Created.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2) validateEnrollment(formats strfmt.Registry) error {

	if swag.IsZero(m.Enrollment) { // not required
		return nil
	}

	if m.Enrollment != nil {
		if err := m.Enrollment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("enrollment")
			}
			return err
		}
	}

	return nil
}

func (m *CourseV2) validateExternalAccessURL(formats strfmt.Registry) error {

	if err := validate.RequiredString("externalAccessUrl", "body", string(m.ExternalAccessURL)); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2) validateExternalID(formats strfmt.Registry) error {

	if swag.IsZero(m.ExternalID) { // not required
		return nil
	}

	if err := validate.MaxLength("externalId", "body", string(m.ExternalID), 256); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2) validateGuestAccessURL(formats strfmt.Registry) error {

	if err := validate.RequiredString("guestAccessUrl", "body", string(m.GuestAccessURL)); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2) validateHasChildren(formats strfmt.Registry) error {

	if err := validate.Required("hasChildren", "body", bool(m.HasChildren)); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2) validateID(formats strfmt.Registry) error {

	if err := validate.RequiredString("id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2) validateLocale(formats strfmt.Registry) error {

	if swag.IsZero(m.Locale) { // not required
		return nil
	}

	if m.Locale != nil {
		if err := m.Locale.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("locale")
			}
			return err
		}
	}

	return nil
}

func (m *CourseV2) validateModified(formats strfmt.Registry) error {

	if err := validate.Required("modified", "body", strfmt.DateTime(m.Modified)); err != nil {
		return err
	}

	if err := validate.FormatOf("modified", "body", "date-time", m.Modified.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", string(*m.Name), 333); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2) validateOrganization(formats strfmt.Registry) error {

	if err := validate.Required("organization", "body", bool(m.Organization)); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2) validateParentID(formats strfmt.Registry) error {

	if err := validate.RequiredString("parentId", "body", string(m.ParentID)); err != nil {
		return err
	}

	return nil
}

var courseV2TypeUltraStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Undecided","Classic","Ultra","UltraPreview"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		courseV2TypeUltraStatusPropEnum = append(courseV2TypeUltraStatusPropEnum, v)
	}
}

const (

	// CourseV2UltraStatusUndecided captures enum value "Undecided"
	CourseV2UltraStatusUndecided string = "Undecided"

	// CourseV2UltraStatusClassic captures enum value "Classic"
	CourseV2UltraStatusClassic string = "Classic"

	// CourseV2UltraStatusUltra captures enum value "Ultra"
	CourseV2UltraStatusUltra string = "Ultra"

	// CourseV2UltraStatusUltraPreview captures enum value "UltraPreview"
	CourseV2UltraStatusUltraPreview string = "UltraPreview"
)

// prop value enum
func (m *CourseV2) validateUltraStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, courseV2TypeUltraStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CourseV2) validateUltraStatus(formats strfmt.Registry) error {

	if err := validate.RequiredString("ultraStatus", "body", string(m.UltraStatus)); err != nil {
		return err
	}

	// value enum
	if err := m.validateUltraStatusEnum("ultraStatus", "body", m.UltraStatus); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2) validateUUID(formats strfmt.Registry) error {

	if err := validate.RequiredString("uuid", "body", string(m.UUID)); err != nil {
		return err
	}

	if err := validate.MaxLength("uuid", "body", string(m.UUID), 32); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CourseV2) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CourseV2) UnmarshalBinary(b []byte) error {
	var res CourseV2
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CourseV2Availability Availability
//
// Settings controlling availability of the course to students.
//
// swagger:model CourseV2Availability
type CourseV2Availability struct {

	// Whether the course is currently available to students. Instructors can always access the course if they have 'Access unavailable course' entitlement. If set to 'Term', the course's parent term availability settings will be used.
	//
	//
	// | Type      | Description
	//  | --------- | --------- |
	// | Yes | Students may access the course. |
	// | No | Students may not access the course. |
	// | Disabled | Disabled by the SIS. Students may not access the course. @since 3100.0.0 |
	// | Term | Availability is inherited from the term settings. Requires a termId be set. |
	//
	// Enum: [Yes No Disabled Term]
	Available string `json:"available,omitempty"`

	// duration
	Duration *CourseV2AvailabilityDuration `json:"duration,omitempty"`
}

// Validate validates this course v2 availability
func (m *CourseV2Availability) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var courseV2AvailabilityTypeAvailablePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Yes","No","Disabled","Term"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		courseV2AvailabilityTypeAvailablePropEnum = append(courseV2AvailabilityTypeAvailablePropEnum, v)
	}
}

const (

	// CourseV2AvailabilityAvailableYes captures enum value "Yes"
	CourseV2AvailabilityAvailableYes string = "Yes"

	// CourseV2AvailabilityAvailableNo captures enum value "No"
	CourseV2AvailabilityAvailableNo string = "No"

	// CourseV2AvailabilityAvailableDisabled captures enum value "Disabled"
	CourseV2AvailabilityAvailableDisabled string = "Disabled"

	// CourseV2AvailabilityAvailableTerm captures enum value "Term"
	CourseV2AvailabilityAvailableTerm string = "Term"
)

// prop value enum
func (m *CourseV2Availability) validateAvailableEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, courseV2AvailabilityTypeAvailablePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CourseV2Availability) validateAvailable(formats strfmt.Registry) error {

	if swag.IsZero(m.Available) { // not required
		return nil
	}

	// value enum
	if err := m.validateAvailableEnum("availability"+"."+"available", "body", m.Available); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2Availability) validateDuration(formats strfmt.Registry) error {

	if swag.IsZero(m.Duration) { // not required
		return nil
	}

	if m.Duration != nil {
		if err := m.Duration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("availability" + "." + "duration")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CourseV2Availability) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CourseV2Availability) UnmarshalBinary(b []byte) error {
	var res CourseV2Availability
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CourseV2AvailabilityDuration Duration
//
// Settings controlling the length of time the course is available.
//
// swagger:model CourseV2AvailabilityDuration
type CourseV2AvailabilityDuration struct {

	// The number of days this course can be used. May only be set if availability.duration.type is FixedNumDays.
	DaysOfUse int32 `json:"daysOfUse,omitempty"`

	// The date this course ends. May only be set if availability.duration.type is DateRange.
	// Format: date-time
	End strfmt.DateTime `json:"end,omitempty"`

	// The date this course starts. May only be set if availability.duration.type is DateRange.
	// Format: date-time
	Start strfmt.DateTime `json:"start,omitempty"`

	// The intended length of the course. Possible values are:
	//
	// - Continuous: The course is active on an ongoing basis. This is the default.
	// - DateRange: The course will only be available between specific date ranges.
	// - FixedNumDays: The course will only be available for a set number of days.
	// - Term: The course's parent term duration settings will be used.
	//
	//
	// | Type      | Description
	//  | --------- | --------- |
	// | Continuous | Course is active on an ongoing basis. |
	// | DateRange | Course is only intended to be available between specific date ranges |
	// | FixedNumDays | Course is only available for a set number of days |
	// | Term | Course availablity is dictated by its associated term |
	//
	// Enum: [Continuous DateRange FixedNumDays Term]
	Type string `json:"type,omitempty"`
}

// Validate validates this course v2 availability duration
func (m *CourseV2AvailabilityDuration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStart(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CourseV2AvailabilityDuration) validateEnd(formats strfmt.Registry) error {

	if swag.IsZero(m.End) { // not required
		return nil
	}

	if err := validate.FormatOf("availability"+"."+"duration"+"."+"end", "body", "date-time", m.End.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2AvailabilityDuration) validateStart(formats strfmt.Registry) error {

	if swag.IsZero(m.Start) { // not required
		return nil
	}

	if err := validate.FormatOf("availability"+"."+"duration"+"."+"start", "body", "date-time", m.Start.String(), formats); err != nil {
		return err
	}

	return nil
}

var courseV2AvailabilityDurationTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Continuous","DateRange","FixedNumDays","Term"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		courseV2AvailabilityDurationTypeTypePropEnum = append(courseV2AvailabilityDurationTypeTypePropEnum, v)
	}
}

const (

	// CourseV2AvailabilityDurationTypeContinuous captures enum value "Continuous"
	CourseV2AvailabilityDurationTypeContinuous string = "Continuous"

	// CourseV2AvailabilityDurationTypeDateRange captures enum value "DateRange"
	CourseV2AvailabilityDurationTypeDateRange string = "DateRange"

	// CourseV2AvailabilityDurationTypeFixedNumDays captures enum value "FixedNumDays"
	CourseV2AvailabilityDurationTypeFixedNumDays string = "FixedNumDays"

	// CourseV2AvailabilityDurationTypeTerm captures enum value "Term"
	CourseV2AvailabilityDurationTypeTerm string = "Term"
)

// prop value enum
func (m *CourseV2AvailabilityDuration) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, courseV2AvailabilityDurationTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CourseV2AvailabilityDuration) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("availability"+"."+"duration"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CourseV2AvailabilityDuration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CourseV2AvailabilityDuration) UnmarshalBinary(b []byte) error {
	var res CourseV2AvailabilityDuration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CourseV2Enrollment Enrollment
//
// Settings controlling how students may enroll in the course.
//
// swagger:model CourseV2Enrollment
type CourseV2Enrollment struct {

	// The enrollment access code associated with this course. May only be set if enrollment.type is SelfEnrollment.
	// Max Length: 50
	AccessCode string `json:"accessCode,omitempty"`

	// The date on which enrollment in this course ends. May only be set if enrollment.type is SelfEnrollment.
	// Format: date-time
	End strfmt.DateTime `json:"end,omitempty"`

	// The date on which enrollments are allowed for the course. May only be set if enrollment.type is SelfEnrollment.
	// Format: date-time
	Start strfmt.DateTime `json:"start,omitempty"`

	// Specifies the enrollment options for the course. Defaults to InstructorLed.
	//
	//
	// | Type      | Description
	//  | --------- | --------- |
	// | InstructorLed | Enrollment tasks for the course can only performed by the instructor |
	// | SelfEnrollment | Instructors have the ability to enroll users, and students can also enroll themselves in the course |
	// | EmailEnrollment | Instructors have the ability to enroll users, and students can email requests to the instructor for enrollment |
	//
	// Enum: [InstructorLed SelfEnrollment EmailEnrollment]
	Type string `json:"type,omitempty"`
}

// Validate validates this course v2 enrollment
func (m *CourseV2Enrollment) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStart(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CourseV2Enrollment) validateAccessCode(formats strfmt.Registry) error {

	if swag.IsZero(m.AccessCode) { // not required
		return nil
	}

	if err := validate.MaxLength("enrollment"+"."+"accessCode", "body", string(m.AccessCode), 50); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2Enrollment) validateEnd(formats strfmt.Registry) error {

	if swag.IsZero(m.End) { // not required
		return nil
	}

	if err := validate.FormatOf("enrollment"+"."+"end", "body", "date-time", m.End.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CourseV2Enrollment) validateStart(formats strfmt.Registry) error {

	if swag.IsZero(m.Start) { // not required
		return nil
	}

	if err := validate.FormatOf("enrollment"+"."+"start", "body", "date-time", m.Start.String(), formats); err != nil {
		return err
	}

	return nil
}

var courseV2EnrollmentTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["InstructorLed","SelfEnrollment","EmailEnrollment"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		courseV2EnrollmentTypeTypePropEnum = append(courseV2EnrollmentTypeTypePropEnum, v)
	}
}

const (

	// CourseV2EnrollmentTypeInstructorLed captures enum value "InstructorLed"
	CourseV2EnrollmentTypeInstructorLed string = "InstructorLed"

	// CourseV2EnrollmentTypeSelfEnrollment captures enum value "SelfEnrollment"
	CourseV2EnrollmentTypeSelfEnrollment string = "SelfEnrollment"

	// CourseV2EnrollmentTypeEmailEnrollment captures enum value "EmailEnrollment"
	CourseV2EnrollmentTypeEmailEnrollment string = "EmailEnrollment"
)

// prop value enum
func (m *CourseV2Enrollment) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, courseV2EnrollmentTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CourseV2Enrollment) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("enrollment"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CourseV2Enrollment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CourseV2Enrollment) UnmarshalBinary(b []byte) error {
	var res CourseV2Enrollment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CourseV2Locale Locale
//
// Settings controlling localization within the course.
//
// swagger:model CourseV2Locale
type CourseV2Locale struct {

	// Whether students are forced to use the course's specified locale.
	Force bool `json:"force,omitempty"`

	// The locale of this course.
	// Max Length: 20
	ID string `json:"id,omitempty"`
}

// Validate validates this course v2 locale
func (m *CourseV2Locale) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CourseV2Locale) validateID(formats strfmt.Registry) error {

	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("locale"+"."+"id", "body", string(m.ID), 20); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CourseV2Locale) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CourseV2Locale) UnmarshalBinary(b []byte) error {
	var res CourseV2Locale
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
