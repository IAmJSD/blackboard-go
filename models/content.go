// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Content content
//
// swagger:model Content
type Content struct {

	// availability
	Availability *ContentAvailability `json:"availability,omitempty"`

	// The body text associated with this content. This field supports BbML; see <a target='_blank' href='https://docs.blackboard.com/learn/REST/Blackboard%20Markup%20Language%20-%20BbML.html'>here</a> for more information.
	Body string `json:"body,omitempty"`

	// Extended settings specific to this content item's content handler.
	ContentHandler *ContentHandler `json:"contentHandler,omitempty"`

	// The date this content was created.
	// Required: true
	// Read Only: true
	// Format: date-time
	Created strfmt.DateTime `json:"created"`

	// The short description of this content.
	//
	// This field is not used in Classic courses.  For Ultra courses this is used to show information directly on the course outline.
	Description string `json:"description,omitempty"`

	// Indicates whether this content item has one or more associated groups.
	//
	// Associated groups can be accessed via /learn/api/public/v1/courses/$courseId/contents/$contentId/groups
	//
	// **Since**: 3100.4.0
	// Required: true
	// Read Only: true
	HasAssociatedGroups bool `json:"hasAssociatedGroups"`

	// Indicates whether this content is allowed to have child content items.
	// Required: true
	// Read Only: true
	HasChildren bool `json:"hasChildren"`

	// Indicates whether this content item has one or more gradebook columns.
	//
	// Associated gradebook columns can be accessed via /learn/api/public/v1/courses/$courseId/gradebook/columns?contentId=$contentId
	//
	// **Since**: 3000.11.0
	// Required: true
	// Read Only: true
	HasGradebookColumns bool `json:"hasGradebookColumns"`

	// The ID of the content.
	// Required: true
	// Read Only: true
	ID string `json:"id"`

	// Indicates whether the content is going to open in a new window.
	//
	// **Since**: 3800.10.0
	LaunchInNewWindow bool `json:"launchInNewWindow,omitempty"`

	// The date this content was modified.
	//
	// **Since**: 3700.4.0
	// Required: true
	// Read Only: true
	// Format: date-time
	Modified strfmt.DateTime `json:"modified"`

	// The ID of the content's parent.  Note that top-level contents do not have parents. The 'parentId' field is a writable field as of the Bb Learn 3200.6.0 release.  Specifying a new value in PATCH requests allows the Content object to be moved from one parent to another.
	ParentID string `json:"parentId,omitempty"`

	// The position of this content within its parent folder. Position values are zero-based (the first element has a position value of zero, not one). Default position is last in the list of child contents under the parent.
	Position int32 `json:"position,omitempty"`

	// Indicates whether Review Status is enabled for this content. Content items with review status enabled can be marked as reviewed by students. This can be used to track performance and in Adaptive Release rules to control the release of other content. Reviewable field is currently being used only in Classic courses.
	//
	// **Since**: 3700.15.0
	Reviewable bool `json:"reviewable,omitempty"`

	// The title or name of this content. Typically shown as the main text to click in the course outline when accessing the content.
	// Required: true
	Title *string `json:"title"`
}

// Validate validates this content
func (m *Content) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailability(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContentHandler(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHasAssociatedGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHasChildren(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHasGradebookColumns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModified(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTitle(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Content) validateAvailability(formats strfmt.Registry) error {

	if swag.IsZero(m.Availability) { // not required
		return nil
	}

	if m.Availability != nil {
		if err := m.Availability.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("availability")
			}
			return err
		}
	}

	return nil
}

func (m *Content) validateContentHandler(formats strfmt.Registry) error {

	if swag.IsZero(m.ContentHandler) { // not required
		return nil
	}

	if m.ContentHandler != nil {
		if err := m.ContentHandler.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("contentHandler")
			}
			return err
		}
	}

	return nil
}

func (m *Content) validateCreated(formats strfmt.Registry) error {

	if err := validate.Required("created", "body", strfmt.DateTime(m.Created)); err != nil {
		return err
	}

	if err := validate.FormatOf("created", "body", "date-time", m.Created.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Content) validateHasAssociatedGroups(formats strfmt.Registry) error {

	if err := validate.Required("hasAssociatedGroups", "body", bool(m.HasAssociatedGroups)); err != nil {
		return err
	}

	return nil
}

func (m *Content) validateHasChildren(formats strfmt.Registry) error {

	if err := validate.Required("hasChildren", "body", bool(m.HasChildren)); err != nil {
		return err
	}

	return nil
}

func (m *Content) validateHasGradebookColumns(formats strfmt.Registry) error {

	if err := validate.Required("hasGradebookColumns", "body", bool(m.HasGradebookColumns)); err != nil {
		return err
	}

	return nil
}

func (m *Content) validateID(formats strfmt.Registry) error {

	if err := validate.RequiredString("id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *Content) validateModified(formats strfmt.Registry) error {

	if err := validate.Required("modified", "body", strfmt.DateTime(m.Modified)); err != nil {
		return err
	}

	if err := validate.FormatOf("modified", "body", "date-time", m.Modified.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Content) validateTitle(formats strfmt.Registry) error {

	if err := validate.Required("title", "body", m.Title); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Content) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Content) UnmarshalBinary(b []byte) error {
	var res Content
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ContentAvailability Availability
//
// Settings controlling availability of the content to students.
//
// swagger:model ContentAvailability
type ContentAvailability struct {

	// adaptive release
	AdaptiveRelease *ContentAvailabilityAdaptiveRelease `json:"adaptiveRelease,omitempty"`

	// Whether this content is available to users with the 'guest' role. Defaults to true.
	AllowGuests bool `json:"allowGuests,omitempty"`

	// Whether the content is currently available to students.  Instructors can always access the content.  If set to 'PartiallyVisible', the title will be available to students but the body will not.  Defaults to Yes.
	//
	//
	// | Type      | Description
	//  | --------- | --------- |
	// | Yes |  |
	// | No |  |
	// | PartiallyVisible |  |
	//
	// Enum: [Yes No PartiallyVisible]
	Available string `json:"available,omitempty"`
}

// Validate validates this content availability
func (m *ContentAvailability) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdaptiveRelease(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailable(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ContentAvailability) validateAdaptiveRelease(formats strfmt.Registry) error {

	if swag.IsZero(m.AdaptiveRelease) { // not required
		return nil
	}

	if m.AdaptiveRelease != nil {
		if err := m.AdaptiveRelease.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("availability" + "." + "adaptiveRelease")
			}
			return err
		}
	}

	return nil
}

var contentAvailabilityTypeAvailablePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Yes","No","PartiallyVisible"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		contentAvailabilityTypeAvailablePropEnum = append(contentAvailabilityTypeAvailablePropEnum, v)
	}
}

const (

	// ContentAvailabilityAvailableYes captures enum value "Yes"
	ContentAvailabilityAvailableYes string = "Yes"

	// ContentAvailabilityAvailableNo captures enum value "No"
	ContentAvailabilityAvailableNo string = "No"

	// ContentAvailabilityAvailablePartiallyVisible captures enum value "PartiallyVisible"
	ContentAvailabilityAvailablePartiallyVisible string = "PartiallyVisible"
)

// prop value enum
func (m *ContentAvailability) validateAvailableEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, contentAvailabilityTypeAvailablePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ContentAvailability) validateAvailable(formats strfmt.Registry) error {

	if swag.IsZero(m.Available) { // not required
		return nil
	}

	// value enum
	if err := m.validateAvailableEnum("availability"+"."+"available", "body", m.Available); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ContentAvailability) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ContentAvailability) UnmarshalBinary(b []byte) error {
	var res ContentAvailability
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ContentAvailabilityAdaptiveRelease AdaptiveRelease
//
// Settings controlling adaptive release of the content to students.
//
// swagger:model ContentAvailabilityAdaptiveRelease
type ContentAvailabilityAdaptiveRelease struct {

	// The date when this content will no longer be available to students.
	// Format: date-time
	End strfmt.DateTime `json:"end,omitempty"`

	// The date when this content will become available to students.
	// Format: date-time
	Start strfmt.DateTime `json:"start,omitempty"`
}

// Validate validates this content availability adaptive release
func (m *ContentAvailabilityAdaptiveRelease) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStart(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ContentAvailabilityAdaptiveRelease) validateEnd(formats strfmt.Registry) error {

	if swag.IsZero(m.End) { // not required
		return nil
	}

	if err := validate.FormatOf("availability"+"."+"adaptiveRelease"+"."+"end", "body", "date-time", m.End.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ContentAvailabilityAdaptiveRelease) validateStart(formats strfmt.Registry) error {

	if swag.IsZero(m.Start) { // not required
		return nil
	}

	if err := validate.FormatOf("availability"+"."+"adaptiveRelease"+"."+"start", "body", "date-time", m.Start.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ContentAvailabilityAdaptiveRelease) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ContentAvailabilityAdaptiveRelease) UnmarshalBinary(b []byte) error {
	var res ContentAvailabilityAdaptiveRelease
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
