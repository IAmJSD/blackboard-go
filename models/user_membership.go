// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UserMembership user membership
//
// swagger:model UserMembership
type UserMembership struct {

	// Settings controlling availability of the course membership.
	Availability *Availability `json:"availability,omitempty"`

	// If present, this date signals that the user associated with this membership has special access to the course regardless of the course's availability setting prior to the moment specified by this field. After the date has passed, the membership will respect the course's availability.
	// Required: true
	// Read Only: true
	// Format: date-time
	BypassCourseAvailabilityUntil strfmt.DateTime `json:"bypassCourseAvailabilityUntil"`

	// The primary ID of the child, cross-listed course, in which the user is directly enrolled. </p> This field is read only in Learn versions 3000.11.0 through 3400.0.0. As of 3400.1.0, this field is mutable.  </p> If this membership's course is a parent course in a cross-listed set, the childCourseId can be updated to move the membership enrollment between child courses and the parent course in  the set.  Patching the childCourseId to "null" will move the membership to the parent course.
	//
	// **Since**: 3000.11.0
	ChildCourseID string `json:"childCourseId,omitempty"`

	// The course associated with the membership.
	//
	// Shown when adding the query parameter: "expand=course". And can be filtered with the "fields" query parameter, for example "fields=course.id,course.externalId".
	//
	// **Since**: 3500.4.0
	// Required: true
	Course *Course `json:"course"`

	// The primary ID of the course.
	// Required: true
	// Read Only: true
	CourseID string `json:"courseId"`

	// The user's role in the course.
	//
	// These roles are also valid for an organization, although they are named differently in the UI.
	//
	// Custom course roles may also be referenced by their IDs.
	//
	//
	// | Type      | Description
	//  | --------- | --------- |
	// | Instructor | Has access to all areas in the Control Panel. This role is generally given to those developing, teaching, or facilitating the class. Instructors may access a course that is unavailable to students. This role is customizable and may have different capabilities from what is documented here. |
	// | BbFacilitator | The facilitator is an instructor like role. Facilitators are restricted versions of an instructor, in that they are able to deliver course instruction and administer all aspects of a pre-constructed course, but are not allowed to modify or alter the course. This role is customizable and may have different capabilities from what is documented here. |
	// | TeachingAssistant | The teaching assistant role is that of a co-teacher. Teaching assistants are able to administer all areas of a course. Their only limitations are those imposed by the instructor or Blackboard administrator at your school. This role is customizable and may have different capabilities from what is documented here. |
	// | CourseBuilder | Manages the course without having access to student grades. This role is customizable and may have different capabilities from what is documented here. |
	// | Grader | Assists the instructor in the creation, management, delivery, and grading of items. This role is customizable and may have different capabilities from what is documented here. |
	// | Student |  |
	// | Guest | Has no access to the Control Panel. Areas within the course are made available to guests, but typically they can only view course materials; they do not have access to tests or assessments, and do not have permission to post on discussion boards. This role's behavior is immutable. |
	//
	// Enum: [Instructor BbFacilitator TeachingAssistant CourseBuilder Grader Student Guest]
	CourseRoleID string `json:"courseRoleId,omitempty"`

	// The date this membership was created.
	// Required: true
	// Read Only: true
	// Format: date-time
	Created strfmt.DateTime `json:"created"`

	// The ID of the data source associated with this course.  This may optionally be the data source's externalId using the syntax "externalId:math101".
	DataSourceID string `json:"dataSourceId,omitempty"`

	// The unique ID of this course/user relationship.
	//
	// **Since**: 3700.14.0
	// Required: true
	// Read Only: true
	ID string `json:"id"`

	// This date signals the date this membership was used; in other words, the last date the user accessed the associated course or content contained by that course.
	//
	// The recording of any activity which would lead to this date getting updated does happen asynchronously in batches. So, there may be some delay between an activity which would update this value and the availability of the new date. It is recommended when using this value to note that activity within the last 5 minutes may not be taken into account.
	//
	// **Since**: 3300.9.0
	// Required: true
	// Read Only: true
	// Format: date-time
	LastAccessed strfmt.DateTime `json:"lastAccessed"`

	// The date this membership was modified.  A membership is considered modified only if an aspect of the membership itself changes (e.g.: availability or courseRoleId), and not if the Course or User alone is modified.
	//
	// **Since**: 3800.8.0
	// Required: true
	// Read Only: true
	// Format: date-time
	Modified strfmt.DateTime `json:"modified"`

	// The primary ID of the user.
	// Required: true
	// Read Only: true
	UserID string `json:"userId"`
}

// Validate validates this user membership
func (m *UserMembership) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailability(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBypassCourseAvailabilityUntil(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCourse(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCourseID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCourseRoleID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastAccessed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModified(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UserMembership) validateAvailability(formats strfmt.Registry) error {

	if swag.IsZero(m.Availability) { // not required
		return nil
	}

	if m.Availability != nil {
		if err := m.Availability.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("availability")
			}
			return err
		}
	}

	return nil
}

func (m *UserMembership) validateBypassCourseAvailabilityUntil(formats strfmt.Registry) error {

	if err := validate.Required("bypassCourseAvailabilityUntil", "body", strfmt.DateTime(m.BypassCourseAvailabilityUntil)); err != nil {
		return err
	}

	if err := validate.FormatOf("bypassCourseAvailabilityUntil", "body", "date-time", m.BypassCourseAvailabilityUntil.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *UserMembership) validateCourse(formats strfmt.Registry) error {

	if err := validate.Required("course", "body", m.Course); err != nil {
		return err
	}

	if m.Course != nil {
		if err := m.Course.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("course")
			}
			return err
		}
	}

	return nil
}

func (m *UserMembership) validateCourseID(formats strfmt.Registry) error {

	if err := validate.RequiredString("courseId", "body", string(m.CourseID)); err != nil {
		return err
	}

	return nil
}

var userMembershipTypeCourseRoleIDPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Instructor","BbFacilitator","TeachingAssistant","CourseBuilder","Grader","Student","Guest"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userMembershipTypeCourseRoleIDPropEnum = append(userMembershipTypeCourseRoleIDPropEnum, v)
	}
}

const (

	// UserMembershipCourseRoleIDInstructor captures enum value "Instructor"
	UserMembershipCourseRoleIDInstructor string = "Instructor"

	// UserMembershipCourseRoleIDBbFacilitator captures enum value "BbFacilitator"
	UserMembershipCourseRoleIDBbFacilitator string = "BbFacilitator"

	// UserMembershipCourseRoleIDTeachingAssistant captures enum value "TeachingAssistant"
	UserMembershipCourseRoleIDTeachingAssistant string = "TeachingAssistant"

	// UserMembershipCourseRoleIDCourseBuilder captures enum value "CourseBuilder"
	UserMembershipCourseRoleIDCourseBuilder string = "CourseBuilder"

	// UserMembershipCourseRoleIDGrader captures enum value "Grader"
	UserMembershipCourseRoleIDGrader string = "Grader"

	// UserMembershipCourseRoleIDStudent captures enum value "Student"
	UserMembershipCourseRoleIDStudent string = "Student"

	// UserMembershipCourseRoleIDGuest captures enum value "Guest"
	UserMembershipCourseRoleIDGuest string = "Guest"
)

// prop value enum
func (m *UserMembership) validateCourseRoleIDEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, userMembershipTypeCourseRoleIDPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UserMembership) validateCourseRoleID(formats strfmt.Registry) error {

	if swag.IsZero(m.CourseRoleID) { // not required
		return nil
	}

	// value enum
	if err := m.validateCourseRoleIDEnum("courseRoleId", "body", m.CourseRoleID); err != nil {
		return err
	}

	return nil
}

func (m *UserMembership) validateCreated(formats strfmt.Registry) error {

	if err := validate.Required("created", "body", strfmt.DateTime(m.Created)); err != nil {
		return err
	}

	if err := validate.FormatOf("created", "body", "date-time", m.Created.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *UserMembership) validateID(formats strfmt.Registry) error {

	if err := validate.RequiredString("id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *UserMembership) validateLastAccessed(formats strfmt.Registry) error {

	if err := validate.Required("lastAccessed", "body", strfmt.DateTime(m.LastAccessed)); err != nil {
		return err
	}

	if err := validate.FormatOf("lastAccessed", "body", "date-time", m.LastAccessed.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *UserMembership) validateModified(formats strfmt.Registry) error {

	if err := validate.Required("modified", "body", strfmt.DateTime(m.Modified)); err != nil {
		return err
	}

	if err := validate.FormatOf("modified", "body", "date-time", m.Modified.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *UserMembership) validateUserID(formats strfmt.Registry) error {

	if err := validate.RequiredString("userId", "body", string(m.UserID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UserMembership) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UserMembership) UnmarshalBinary(b []byte) error {
	var res UserMembership
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
