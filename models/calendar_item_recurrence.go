// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CalendarItemRecurrence calendar item recurrence
//
// swagger:model CalendarItemRecurrence
type CalendarItemRecurrence struct {

	// Recurrence count indicating how many times the calendar item should be repeated. Either this count OR the 'until' date is/'should be' set. When creating a calendar item, 'until' date will be used if both 'until' date and the count are set.
	Count int32 `json:"count,omitempty"`

	// Frequency of the calendar item repeated.
	//
	//
	// | Type      | Description
	//  | --------- | --------- |
	// | Monthly |  |
	// | Weekly |  |
	// | Daily |  |
	//
	// Enum: [Monthly Weekly Daily]
	Frequency string `json:"frequency,omitempty"`

	// Interval between recurrences depends on the repeating type. For example, if the calendar times should be repeated every three weeks, you need set interval to 3 as well as frequency to "Weekly". Minimum and Maximum allowed Intervals are 1 and 100 respectively.
	Interval int32 `json:"interval,omitempty"`

	// This property is used in conjunction with the 'Monthly' frequency and it indicates that the calendar item is/'should be' repeated on nth occurrence of 'repeatDay' in the month. Valid values for 'monthPosition' are integers in the range of -1 and 4 inclusive: -1 for the last occurrence, 1 for the first occurrence, 2 for the second occurrence, and so on. 0 is not used.
	MonthPosition int32 `json:"monthPosition,omitempty"`

	// This property is used in conjunction with the 'Monthly' frequency and it indicates on which day of the month the calendar item is/'should be' repeated on. The valid values are valid month days, that is, 1 to 31. Either this OR both 'monthPosition' and 'repeatDay' should be set to create a recurring calendar item with 'Monthly' frequency.
	MonthRepeatDay int32 `json:"monthRepeatDay,omitempty"`

	// The original end date for the calendar item.
	// Format: date-time
	OriginalEnd strfmt.DateTime `json:"originalEnd,omitempty"`

	// The original start date for the calendar item.
	// Format: date-time
	OriginalStart strfmt.DateTime `json:"originalStart,omitempty"`

	// Calendar item that's repeated is part of a recurring series of calendar events but the item has been changed since its original creation. In other words, the calendar item has been modified to no longer align with the recurring series (day/time changed for example) of events. This can only be true if the calendar item is repeatable.
	RepeatBroken bool `json:"repeatBroken,omitempty"`

	// For monthly recurring event, repeat by day of week.
	//
	//
	// | Type      | Description
	//  | --------- | --------- |
	// | Sunday |  |
	// | Monday |  |
	// | Tuesday |  |
	// | Wednesday |  |
	// | Thursday |  |
	// | Friday |  |
	// | Saturday |  |
	//
	// Enum: [Sunday Monday Tuesday Wednesday Thursday Friday Saturday]
	RepeatDay string `json:"repeatDay,omitempty"`

	// The date the calendar item should be repeated until. Either this 'until' date OR the count is/'should be' set. When creating a calendar item, 'until' date will be used if both 'until' date and the count are set.
	// Format: date-time
	Until strfmt.DateTime `json:"until,omitempty"`

	// This property is used in conjunction with the 'Weekly' frequency and it indicates the days of the week the calendar item should be repeated on.
	WeekDays []BYDAYEnum `json:"weekDays"`
}

// Validate validates this calendar item recurrence
func (m *CalendarItemRecurrence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginalEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginalStart(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRepeatDay(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUntil(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWeekDays(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var calendarItemRecurrenceTypeFrequencyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Monthly","Weekly","Daily"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		calendarItemRecurrenceTypeFrequencyPropEnum = append(calendarItemRecurrenceTypeFrequencyPropEnum, v)
	}
}

const (

	// CalendarItemRecurrenceFrequencyMonthly captures enum value "Monthly"
	CalendarItemRecurrenceFrequencyMonthly string = "Monthly"

	// CalendarItemRecurrenceFrequencyWeekly captures enum value "Weekly"
	CalendarItemRecurrenceFrequencyWeekly string = "Weekly"

	// CalendarItemRecurrenceFrequencyDaily captures enum value "Daily"
	CalendarItemRecurrenceFrequencyDaily string = "Daily"
)

// prop value enum
func (m *CalendarItemRecurrence) validateFrequencyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, calendarItemRecurrenceTypeFrequencyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CalendarItemRecurrence) validateFrequency(formats strfmt.Registry) error {

	if swag.IsZero(m.Frequency) { // not required
		return nil
	}

	// value enum
	if err := m.validateFrequencyEnum("frequency", "body", m.Frequency); err != nil {
		return err
	}

	return nil
}

func (m *CalendarItemRecurrence) validateOriginalEnd(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginalEnd) { // not required
		return nil
	}

	if err := validate.FormatOf("originalEnd", "body", "date-time", m.OriginalEnd.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CalendarItemRecurrence) validateOriginalStart(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginalStart) { // not required
		return nil
	}

	if err := validate.FormatOf("originalStart", "body", "date-time", m.OriginalStart.String(), formats); err != nil {
		return err
	}

	return nil
}

var calendarItemRecurrenceTypeRepeatDayPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		calendarItemRecurrenceTypeRepeatDayPropEnum = append(calendarItemRecurrenceTypeRepeatDayPropEnum, v)
	}
}

const (

	// CalendarItemRecurrenceRepeatDaySunday captures enum value "Sunday"
	CalendarItemRecurrenceRepeatDaySunday string = "Sunday"

	// CalendarItemRecurrenceRepeatDayMonday captures enum value "Monday"
	CalendarItemRecurrenceRepeatDayMonday string = "Monday"

	// CalendarItemRecurrenceRepeatDayTuesday captures enum value "Tuesday"
	CalendarItemRecurrenceRepeatDayTuesday string = "Tuesday"

	// CalendarItemRecurrenceRepeatDayWednesday captures enum value "Wednesday"
	CalendarItemRecurrenceRepeatDayWednesday string = "Wednesday"

	// CalendarItemRecurrenceRepeatDayThursday captures enum value "Thursday"
	CalendarItemRecurrenceRepeatDayThursday string = "Thursday"

	// CalendarItemRecurrenceRepeatDayFriday captures enum value "Friday"
	CalendarItemRecurrenceRepeatDayFriday string = "Friday"

	// CalendarItemRecurrenceRepeatDaySaturday captures enum value "Saturday"
	CalendarItemRecurrenceRepeatDaySaturday string = "Saturday"
)

// prop value enum
func (m *CalendarItemRecurrence) validateRepeatDayEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, calendarItemRecurrenceTypeRepeatDayPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CalendarItemRecurrence) validateRepeatDay(formats strfmt.Registry) error {

	if swag.IsZero(m.RepeatDay) { // not required
		return nil
	}

	// value enum
	if err := m.validateRepeatDayEnum("repeatDay", "body", m.RepeatDay); err != nil {
		return err
	}

	return nil
}

func (m *CalendarItemRecurrence) validateUntil(formats strfmt.Registry) error {

	if swag.IsZero(m.Until) { // not required
		return nil
	}

	if err := validate.FormatOf("until", "body", "date-time", m.Until.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CalendarItemRecurrence) validateWeekDays(formats strfmt.Registry) error {

	if swag.IsZero(m.WeekDays) { // not required
		return nil
	}

	for i := 0; i < len(m.WeekDays); i++ {

		if err := m.WeekDays[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("weekDays" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CalendarItemRecurrence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CalendarItemRecurrence) UnmarshalBinary(b []byte) error {
	var res CalendarItemRecurrence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
