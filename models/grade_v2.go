// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// GradeV2 grade v2
//
// swagger:model GradeV2
type GradeV2 struct {

	// The change index associated with this grade which indicates what relative point in time the grade was created or last updated.
	// Required: true
	// Read Only: true
	ChangeIndex int64 `json:"changeIndex"`

	// The grade column ID for this grade.
	// Required: true
	// Read Only: true
	ColumnID string `json:"columnId"`

	// Whether the grade for a calculated column could be successfully computed.
	// Required: true
	// Read Only: true
	Corrupt bool `json:"corrupt"`

	// The primary display grade associated with this grade. Secondary display grade is not exposed via API
	// Required: true
	DisplayGrade *DisplayGrade `json:"displayGrade"`

	// Whether the score associated with this grade is ignored when computing the course grade.
	Exempt bool `json:"exempt,omitempty"`

	// The instructor feedback associated with this grade.  This feedback is used for grades on manual grade columns.   That is, when column.grading.type = Manual.  It is also used when column.grading.type = Attempts and the grade has been manually overridden.
	Feedback string `json:"feedback,omitempty"`

	// The Id of a Grade Notation which can be optionally associated with this Grade. If a Grade Notation is specified for this Grade, then the DisplayGrade's Text attribute will contain the Grade Notation's Description.
	GradeNotationID string `json:"gradeNotationId,omitempty"`

	// The instructor notes associated with this grade. This notes field is used for grades on manual grade columns.   That is, when column.grading.type = Manual.  It is also used when column.grading.type = Attempts and the grade has been manually overridden.
	Notes string `json:"notes,omitempty"`

	// The date on which the score associated with this grade was last overridden.  An ISODate value is only returned if this grade is currently overridden; otherwise, returns null.
	// Required: true
	// Read Only: true
	// Format: date-time
	Overridden strfmt.DateTime `json:"overridden"`

	// The score associated with this grade.
	Score float64 `json:"score,omitempty"`

	// The status of this grade.
	//
	//
	// | Type      | Description
	//  | --------- | --------- |
	// | Graded | Grade has been graded, corresponding to dbValue 1 |
	// | NeedsGrading | Grade needs grading, corresponding to dbValue 2 |
	//
	// Required: true
	// Read Only: true
	// Enum: [Graded NeedsGrading]
	Status string `json:"status"`

	// The text representation of this grade.
	Text string `json:"text,omitempty"`

	// The user ID associated with this grade.
	// Required: true
	// Read Only: true
	UserID string `json:"userId"`
}

// Validate validates this grade v2
func (m *GradeV2) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateChangeIndex(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateColumnID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCorrupt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplayGrade(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverridden(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GradeV2) validateChangeIndex(formats strfmt.Registry) error {

	if err := validate.Required("changeIndex", "body", int64(m.ChangeIndex)); err != nil {
		return err
	}

	return nil
}

func (m *GradeV2) validateColumnID(formats strfmt.Registry) error {

	if err := validate.RequiredString("columnId", "body", string(m.ColumnID)); err != nil {
		return err
	}

	return nil
}

func (m *GradeV2) validateCorrupt(formats strfmt.Registry) error {

	if err := validate.Required("corrupt", "body", bool(m.Corrupt)); err != nil {
		return err
	}

	return nil
}

func (m *GradeV2) validateDisplayGrade(formats strfmt.Registry) error {

	if err := validate.Required("displayGrade", "body", m.DisplayGrade); err != nil {
		return err
	}

	if m.DisplayGrade != nil {
		if err := m.DisplayGrade.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("displayGrade")
			}
			return err
		}
	}

	return nil
}

func (m *GradeV2) validateOverridden(formats strfmt.Registry) error {

	if err := validate.Required("overridden", "body", strfmt.DateTime(m.Overridden)); err != nil {
		return err
	}

	if err := validate.FormatOf("overridden", "body", "date-time", m.Overridden.String(), formats); err != nil {
		return err
	}

	return nil
}

var gradeV2TypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Graded","NeedsGrading"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		gradeV2TypeStatusPropEnum = append(gradeV2TypeStatusPropEnum, v)
	}
}

const (

	// GradeV2StatusGraded captures enum value "Graded"
	GradeV2StatusGraded string = "Graded"

	// GradeV2StatusNeedsGrading captures enum value "NeedsGrading"
	GradeV2StatusNeedsGrading string = "NeedsGrading"
)

// prop value enum
func (m *GradeV2) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, gradeV2TypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *GradeV2) validateStatus(formats strfmt.Registry) error {

	if err := validate.RequiredString("status", "body", string(m.Status)); err != nil {
		return err
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *GradeV2) validateUserID(formats strfmt.Registry) error {

	if err := validate.RequiredString("userId", "body", string(m.UserID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GradeV2) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GradeV2) UnmarshalBinary(b []byte) error {
	var res GradeV2
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
