// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CalendarItem calendar item
//
// swagger:model CalendarItem
type CalendarItem struct {

	// Calendar source identifier which indicates the calendar on which the calendar item was created. Examples of possible values : "PERSONAL", "INSTITUTION", and course id in the format of "_3_1".
	// Required: true
	// Read Only: true
	CalendarID string `json:"calendarId"`

	// Calendar source label/display name.
	// Required: true
	// Read Only: true
	CalendarName string `json:"calendarName"`

	// Color to use for the calendar item. It's a shared setting for all calendar items with the same calendar source identifier.
	// Required: true
	// Read Only: true
	Color string `json:"color"`

	// Get the user who created this calendar item. This will be null for non-personal events when the creator has been deleted.
	// Required: true
	// Read Only: true
	CreatedByUserID string `json:"createdByUserId"`

	// Description of the calendar item.
	Description string `json:"description,omitempty"`

	// Whether resizing of the calendar item should NOT be allowed.
	DisableResizing bool `json:"disableResizing,omitempty"`

	// dynamic calendar item props
	// Required: true
	DynamicCalendarItemProps *CalendarItemDynamicCalendarItemProps `json:"dynamicCalendarItemProps"`

	// End date of the calendar item either in the past if the calendar item is for an event that's already end OR in the future if it's for an event to end in the future. This is always set and should occur after the start date.
	// Format: date-time
	End strfmt.DateTime `json:"end,omitempty"`

	// Calendar item identifier that indicates the id of the calendar item source which the item was created from. (Ex. '_417_1')
	// Required: true
	// Read Only: true
	ID string `json:"id"`

	// Location of the calendar item and it cannot exceed 1024 characters.
	Location string `json:"location,omitempty"`

	// Date when the calendar item was last modified.
	// Required: true
	// Read Only: true
	// Format: date-time
	Modified strfmt.DateTime `json:"modified"`

	// Recurring definition if the calendar item is a repeatable calendar item. This object must be defined for <code>OfficeHours</code> type calendar items.
	Recurrence *CalendarItemRecurrence `json:"recurrence,omitempty"`

	// Start date of the calendar item either in the past if the calendar item is for an event that's already started OR in the future if it's for an event to start in the future. This is always set and should occur before the end date.
	// Format: date-time
	Start strfmt.DateTime `json:"start,omitempty"`

	// Title of the calendar item. Title length cannot exceed 255 characters.
	Title string `json:"title,omitempty"`

	// The type of this Calendar Item.
	//
	//
	// | Type      | Description
	//  | --------- | --------- |
	// | Course |  |
	// | GradebookColumn | Read only. |
	// | Institution |  |
	// | OfficeHours |  |
	// | Personal |  |
	//
	// Required: true
	// Read Only: true
	// Enum: [Course GradebookColumn Institution OfficeHours Personal]
	Type string `json:"type"`
}

// Validate validates this calendar item
func (m *CalendarItem) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCalendarID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCalendarName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateColor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedByUserID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDynamicCalendarItemProps(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModified(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecurrence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStart(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CalendarItem) validateCalendarID(formats strfmt.Registry) error {

	if err := validate.RequiredString("calendarId", "body", string(m.CalendarID)); err != nil {
		return err
	}

	return nil
}

func (m *CalendarItem) validateCalendarName(formats strfmt.Registry) error {

	if err := validate.RequiredString("calendarName", "body", string(m.CalendarName)); err != nil {
		return err
	}

	return nil
}

func (m *CalendarItem) validateColor(formats strfmt.Registry) error {

	if err := validate.RequiredString("color", "body", string(m.Color)); err != nil {
		return err
	}

	return nil
}

func (m *CalendarItem) validateCreatedByUserID(formats strfmt.Registry) error {

	if err := validate.RequiredString("createdByUserId", "body", string(m.CreatedByUserID)); err != nil {
		return err
	}

	return nil
}

func (m *CalendarItem) validateDynamicCalendarItemProps(formats strfmt.Registry) error {

	if err := validate.Required("dynamicCalendarItemProps", "body", m.DynamicCalendarItemProps); err != nil {
		return err
	}

	if m.DynamicCalendarItemProps != nil {
		if err := m.DynamicCalendarItemProps.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dynamicCalendarItemProps")
			}
			return err
		}
	}

	return nil
}

func (m *CalendarItem) validateEnd(formats strfmt.Registry) error {

	if swag.IsZero(m.End) { // not required
		return nil
	}

	if err := validate.FormatOf("end", "body", "date-time", m.End.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CalendarItem) validateID(formats strfmt.Registry) error {

	if err := validate.RequiredString("id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *CalendarItem) validateModified(formats strfmt.Registry) error {

	if err := validate.Required("modified", "body", strfmt.DateTime(m.Modified)); err != nil {
		return err
	}

	if err := validate.FormatOf("modified", "body", "date-time", m.Modified.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CalendarItem) validateRecurrence(formats strfmt.Registry) error {

	if swag.IsZero(m.Recurrence) { // not required
		return nil
	}

	if m.Recurrence != nil {
		if err := m.Recurrence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recurrence")
			}
			return err
		}
	}

	return nil
}

func (m *CalendarItem) validateStart(formats strfmt.Registry) error {

	if swag.IsZero(m.Start) { // not required
		return nil
	}

	if err := validate.FormatOf("start", "body", "date-time", m.Start.String(), formats); err != nil {
		return err
	}

	return nil
}

var calendarItemTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Course","GradebookColumn","Institution","OfficeHours","Personal"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		calendarItemTypeTypePropEnum = append(calendarItemTypeTypePropEnum, v)
	}
}

const (

	// CalendarItemTypeCourse captures enum value "Course"
	CalendarItemTypeCourse string = "Course"

	// CalendarItemTypeGradebookColumn captures enum value "GradebookColumn"
	CalendarItemTypeGradebookColumn string = "GradebookColumn"

	// CalendarItemTypeInstitution captures enum value "Institution"
	CalendarItemTypeInstitution string = "Institution"

	// CalendarItemTypeOfficeHours captures enum value "OfficeHours"
	CalendarItemTypeOfficeHours string = "OfficeHours"

	// CalendarItemTypePersonal captures enum value "Personal"
	CalendarItemTypePersonal string = "Personal"
)

// prop value enum
func (m *CalendarItem) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, calendarItemTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CalendarItem) validateType(formats strfmt.Registry) error {

	if err := validate.RequiredString("type", "body", string(m.Type)); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CalendarItem) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CalendarItem) UnmarshalBinary(b []byte) error {
	var res CalendarItem
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CalendarItemDynamicCalendarItemProps DynamicCalendarItemProps
//
// Extra calendar item properties if it is a GradebookColumn calendar item.
//
// swagger:model CalendarItemDynamicCalendarItemProps
type CalendarItemDynamicCalendarItemProps struct {

	// The dynamic calendar item can be attempted (can have attempts made against it) and the current user (in context) has permission/entitlement to grade attempts for the object represented by this calendar item.
	Attemptable bool `json:"attemptable,omitempty"`

	// Returns the gradeableItem categoryId value .it is only set if the calendar event is dynamically created based on a single grade book column
	CategoryID string `json:"categoryId,omitempty"`

	// The dynamic calendar item is only visible during a specific windows of time.
	DateRangeLimited bool `json:"dateRangeLimited,omitempty"`

	// Returns a human readable string describing the type of calendar item represented (e.g. assignment, test, etc.).
	EventType string `json:"eventType,omitempty"`

	// The dynamic calendar item can be graded and the current user (in context) has permission/entitlement to grade attempts for the object represented by this calendar item.
	Gradable bool `json:"gradable,omitempty"`
}

// Validate validates this calendar item dynamic calendar item props
func (m *CalendarItemDynamicCalendarItemProps) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CalendarItemDynamicCalendarItemProps) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CalendarItemDynamicCalendarItemProps) UnmarshalBinary(b []byte) error {
	var res CalendarItemDynamicCalendarItemProps
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
